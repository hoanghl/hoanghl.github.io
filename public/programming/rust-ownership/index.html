<!doctype html><html lang=en><head data-base-url=https://hoanghl.io/ data-build-search-index=true data-comments-enabled=true data-giscus-category=General data-giscus-category-id=DIC_kwDOLQ4cp84CdIjK data-giscus-crossorigin=anonymous data-giscus-emit-metadata=0 data-giscus-input-position=bottom data-giscus-lang=en data-giscus-mapping=url data-giscus-nonce data-giscus-reactions-enabled=0 data-giscus-repo=kuznetsov17/pico data-giscus-repo-id=R_kgDOLQ4cpw data-giscus-src=https://giscus.app/client.js data-giscus-strict=0><meta charset=utf-8><title>Ownership, pointer and reference</title><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.css integrity=sha384-o3WH+1yEhq+grOgz1BVYTZPyTlMXrDxnjN1By9/ba94JqJhva6wFm2Hb+URQX53v rel=stylesheet><script crossorigin defer integrity=sha384-C5yZTsgLOfuizO9kb+hrB8uSBwwvZ4yenKWU0KmWl+7bkL6Tph/KbcOa3S4zdoRE src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh onload=renderMathInElement(document.body); src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js></script><link href=https://hoanghl.io/site.css rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.css integrity=sha384-o3WH+1yEhq+grOgz1BVYTZPyTlMXrDxnjN1By9/ba94JqJhva6wFm2Hb+URQX53v rel=stylesheet><meta content="Some Description" name=description><meta content="Hoang Le" name=author><meta content=programming,rust name=keywords><link href="https://hoanghl.io/css/grid.css?v=29062025103816" rel=stylesheet><link href="https://hoanghl.io/css/style.css?v=29062025103816" rel=stylesheet><link href=https://hoanghl.io/images/letter.jpg rel=icon type=image/png><link href=https://hoanghl.io/images/letter.jpg rel=mask-icon type=image/png><script src="https://hoanghl.io/js/codecopy.js?v=29062025103816"></script><script src="https://hoanghl.io/js/mermaid.min.js?v=29062025103816"></script><script src="https://hoanghl.io/elasticlunr.min.js?v=29062025103816"></script><script src="https://hoanghl.io/js/search.js?v=29062025103816"></script><body><header><div class=container id=header-container><div class=row><div class=col-2></div><div class=col-8 id=top><div id=menu><ul><li><a href=https://hoanghl.io/>home</a><li><a class=active href=https://hoanghl.io/programming>programming</a><li><a href=https://hoanghl.io/data-world>data-world</a></ul></div><div id=searchBox><span class="icon icon-search head"></span><input id=searchInput name=search></div><span class="icon head" id=cIcon></span></div><div class=col-2></div></div></div></header><div class=row><div class=col-12><div id=sResults><ul class=search-results id=sResultsUL></ul></div></div></div><main><div class=container id=main-container><div class=row><div class=col-2></div><div class="col-8 content"><h1 class=center>Ownership, pointer and reference</h1><span class=post-tags> <ul><li><a class=singlepost-tags href=https://hoanghl.io/tags/rust/>#rust</a> <li><a class=singlepost-tags href=https://hoanghl.io/tags/programming/>#programming</a> </ul> </span><div><p>In Python, when you first assign a variable to a value such as<pre class=language-python data-lang=python style=color:#eff;background-color:#212121><code class=language-python data-lang=python><span>x </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>23
</span></code></pre><p>what happens under the hood is that Python creates a 4-byte-size area in the memory, assigns value 23 for it and binds the variable <code>x</code> for that memory. Later, when you do<pre class=language-python data-lang=python style=color:#eff;background-color:#212121><code class=language-python data-lang=python><span>y </span><span style=color:#89ddff>= </span><span>x
</span></code></pre><p>you are assigning another reference of the above 4-byte-size memory area for <code>y</code>. In other words, this 4-byte-size memory area has two references and we can use either of them to access the memory area.<p>In addition, Python has 4 immutable types (i.e. the types which cannot be modified) and they are <code>int</code>, <code>float</code>, <code>str</code> and <code>tuple</code>. For example, in the following snippet,<pre class=language-python data-lang=python style=color:#eff;background-color:#212121><code class=language-python data-lang=python><span>y </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>4
</span><span>x </span><span style=color:#89ddff>= </span><span>y
</span><span>y </span><span style=color:#89ddff>+= </span><span style=color:#f78c6c>5
</span><span>x </span><span style=color:#89ddff>+= </span><span style=color:#f78c6c>43
</span></code></pre><p>line 2 means that the memory area containing value 4 now has two references namely <code>x</code> and <code>y</code>. In line 3, <code>y</code> is bind to a new memory area and this area contains value 9. After this line, memory area holding value 4 is only referred by <code>x</code>. In line 4, <code>x</code> in turns is referred to new memory area containing value 47. After line 4, memory area holding value 4 isn’t referred by any reference, which is later freed by garbage collector. Check out https://nedbatchelder.com/text/names1.html for more.<p>In Rust, the assignment behaves mostly the same. Taking the following snippet for example.<pre class=language-rust data-lang=rust style=color:#eff;background-color:#212121><code class=language-rust data-lang=rust><span style=color:#c792ea;font-style:italic>let</span><span> x </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>3</span><span style=color:#89ddff>;
</span><span style=color:#c792ea;font-style:italic>let</span><span> y </span><span style=color:#89ddff>=</span><span> x</span><span style=color:#89ddff>;
</span><span>
</span></code></pre><p>Owner: when you assign a variable to a specific value, that variable is the owner of that value and that value can only have one owner at a time<p>Move: when you transfer the ownership of the resource to a specific variable, it’s called move. There are 2 operations that change the ownership of the resource:<ul><li>first assignment of a variable to that resource<li>passing resource as an argument to a function</ul><p>If for some reason, the resource is taken its owner, it will be freed. In either of 2 above operations, there are scenarios which can lead to the memory’s being free. For variable assignment, if that variable is set to <code>mut</code> and later it is assigned to another resource, then the first resource will bee<p>TODO: What do <code>&</code> , <code>*</code>, reference, deference, <code>mut</code> , <code>&mut</code>mean and how to they relate?<p><code>mut</code> is a Rust keyword indicating that the object can be modified. By default, every variable in Rust is immutable. <code>mut</code> is only applied onto a variable, a reference and a pointer. Examples for 3 cases are described below.<pre class=language-rust data-lang=rust style=color:#eff;background-color:#212121><code class=language-rust data-lang=rust><span style=color:#4a4a4a;font-style:italic>// Case 1: mut with variable
</span><span style=color:#c792ea;font-style:italic>let </span><span style=color:#c792ea>mut</span><span> a </span><span style=color:#89ddff>= </span><span style=color:#ffcb6b>String</span><span style=color:#89ddff>::</span><span>from</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>Hellow</span><span style=color:#89ddff>");
</span><span>
</span><span style=color:#4a4a4a;font-style:italic>//Case 2.1: mut with reference in variable declaration
</span><span style=color:#c792ea;font-style:italic>let</span><span> b </span><span style=color:#89ddff>= &</span><span style=color:#c792ea>mut</span><span> a</span><span style=color:#89ddff>;
</span><span style=color:#4a4a4a;font-style:italic>// Case 2.2: mut with reference in function prototype
</span><span style=color:#c792ea;font-style:italic>fn </span><span style=color:#82aaff>modify</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>c</span><span style=color:#89ddff>: &</span><span style=color:#c792ea>mut</span><span> String</span><span style=color:#89ddff>) {}
</span><span>
</span><span style=color:#4a4a4a;font-style:italic>// Case 3: mut with raw pointer
</span><span style=color:#4a4a4a;font-style:italic>// TODO: I will fill this later
</span></code></pre><p>At any given time, there is only one mutable reference corresponding to the resource. For example, the following snippet raises error.<pre class=language-rust data-lang=rust style=color:#eff;background-color:#212121><code class=language-rust data-lang=rust><span style=color:#c792ea;font-style:italic>struct </span><span>Person </span><span style=color:#89ddff>{</span><span>height</span><span style=color:#89ddff>: </span><span style=color:#ffcb6b>Option</span><span style=color:#89ddff><</span><span style=color:#c792ea;font-style:italic>f32</span><span style=color:#89ddff>></span><span>, age</span><span style=color:#89ddff>: </span><span style=color:#ffcb6b>Option</span><span style=color:#89ddff><</span><span style=color:#c792ea;font-style:italic>i32</span><span style=color:#89ddff>>};
</span><span style=color:#c792ea;font-style:italic>let </span><span style=color:#c792ea>mut</span><span> s </span><span style=color:#89ddff>=</span><span> Person </span><span style=color:#89ddff>{</span><span>height</span><span style=color:#89ddff>: </span><span style=color:#ffcb6b>None</span><span style=color:#89ddff>,</span><span> age</span><span style=color:#89ddff>: </span><span style=color:#ffcb6b>None</span><span style=color:#89ddff>};
</span><span style=color:#c792ea;font-style:italic>let</span><span> b </span><span style=color:#89ddff>= &</span><span style=color:#c792ea>mut</span><span> s</span><span style=color:#89ddff>;
</span><span style=color:#c792ea;font-style:italic>let</span><span> c </span><span style=color:#89ddff>= &</span><span style=color:#c792ea>mut</span><span> s</span><span style=color:#89ddff>;
</span><span>s</span><span style=color:#89ddff>.</span><span>height </span><span style=color:#89ddff>= </span><span style=color:#ffcb6b>Some</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>1233.2</span><span style=color:#89ddff>);
</span><span>b</span><span style=color:#89ddff>.</span><span>age </span><span style=color:#89ddff>= </span><span style=color:#ffcb6b>Some</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>432423</span><span style=color:#89ddff>);
</span></code></pre><p>Denote the memory area holding the value of struct <code>Person</code> as <strong>A</strong> and variable <code>s</code> is having the ownership onto this memory area. After line 3, this ownership is borrowed by variable <code>b</code> and since then, only <code>b</code> has the right to modify A, even <code>s</code> which is holding the ownership isn’t allowed for modification. Therefore, line 4 and 5 will raise error.</div></div><div class=col-2></div></div><div class="row postnav"><div class=col-2></div><div class=col-8><div class="col-6 left"></div><div class="col-6 right"><a class=postnav href=https://hoanghl.io/programming/rust-lifetime/>Lifetime in Rust →</a></div></div><div class=col-2></div></div></div><div class=row><div class=col-2></div><div class=col-8 id=giscusWidget></div></div></main><script src="https://hoanghl.io/js/colortheme.js?v=29062025103816"></script><script src="https://hoanghl.io/js/init.js?v=29062025103816"></script>